using System.Diagnostics;
using System.Text;
using ByteSizeLib;
using PeNet.Header.Pe;
using CommandLine;
using Microsoft.VisualBasic;
using Newtonsoft.Json;
using PeNet;

// Parse the command-line arguments
Parser.Default.ParseArguments<Options>(args)
    .WithParsed(opt =>
    {
        // If the input client doesn't exist, exit with an error.
        if (!File.Exists(opt.Input))
        {
            Console.WriteLine($"Input file doesn't exist: {opt.Input}");
            Environment.Exit(1);
        }

        // Delete the compiled client if it already exists.
        if (File.Exists(opt.Output))
        {
            File.Delete(opt.Output);
        }
        
        // Open the input client
        var pe = new PeFile(opt.Input);

        // Modify the binary
        ModifyBinary(pe, opt);
        
        // Generate the metadata code
        BuildMetadata(pe, opt);
    });

void ModifyBinary(PeFile pe, Options opt)
{       
    // Parse the imports
    var importText = File.ReadAllText("src/imports.json");
    var imports = JsonConvert.DeserializeObject<List<Import>>(importText);
        
    // Add the imports
    if (imports is not null)
    {
        var additional = imports.Select(i => new AdditionalImport(i.Module, i.Functions))
            .ToList();
        pe.AddImports(additional);
    }

    // Add a new code section
    pe.AddSection(opt.SectionName, (int)ByteSize.Parse(opt.SectionSize).Bytes, 
        ScnCharacteristicsType.CntCode | ScnCharacteristicsType.MemExecute | ScnCharacteristicsType.MemRead | ScnCharacteristicsType.MemWrite);

    // Save the changes to the output file
    File.WriteAllBytes(opt.Output, pe.RawFile.ToArray());
}

void BuildMetadata(PeFile pe, Options opt)
{
    // Get the current commit
    var commit = "undefined";
    try
    {
        var process = new Process();
        process.StartInfo.UseShellExecute = false;
        process.StartInfo.RedirectStandardOutput = true;
        process.StartInfo.FileName = "git";
        process.StartInfo.Arguments = "rev-parse --short HEAD";
        process.Start();

        commit = process.StandardOutput.ReadToEnd().TrimEnd();
    }
    catch (Exception)
    {
        Console.WriteLine("Failed to get commit, defaulting to 'undefined'.");
    }

    // Get the version tag
    var version = Environment.GetEnvironmentVariable("RELEASE_TAG") ?? "0.0.1";
    
    // Generate a metadata file
    var metadata = new StringBuilder();
    metadata.Append("%ifndef eden_metadata\n");
    metadata.Append("%define eden_metadata\n");
    metadata.Append($"METADATA__GIT_COMMIT:\n db \"{commit}\", 0\n");
    metadata.Append($"METADATA__VERSION_REF:\n db \"{version}\", 0\n");
    metadata.Append("%endif");
    File.WriteAllText("src/eden/metadata.asm", metadata.ToString());
    
    // Collect all the patches.
    var patches = Directory.EnumerateFiles("src/patches", "*.asm", SearchOption.AllDirectories)
        .Select(p => p.Replace(Path.DirectorySeparatorChar, '/'))
        .ToList();
    patches.Sort();
    // Collect all of the definitions.
    var defs = Directory.EnumerateFiles("src/defs", "*.asm", SearchOption.AllDirectories)
        .Select(p => p.Replace(Path.DirectorySeparatorChar, '/'));
    // Collect all of the custom code
    var eden = Directory.EnumerateFiles("src/eden", "*.asm", SearchOption.AllDirectories)
        .Select(p => p.Replace(Path.DirectorySeparatorChar, '/'));
    
    // Start building the metadata file.
    var bldr = new StringBuilder();
    bldr.Append("; ============================================\n");
    bldr.Append("; WARNING: THIS FILE IS AUTOMATICALLY GENERATED. DO NOT MODIFY.\n");
    bldr.Append("; ============================================\n");
    bldr.Append("bits 32\n");
    bldr.Append($"%define BUILD_{opt.Profile.ToUpper()}\n");
    BuildMacros(bldr, pe, opt);
    
    // Include all of the definitions
    foreach (var def in defs)
    {
        bldr.Append($"%include \"{def}\"\n");
    }
    
    // Include all of the patches
    bldr.Append("goto_sect .text\n");
    foreach (var patch in patches)
    {
        Console.WriteLine(patch);
        bldr.Append($"%include \"{patch}\"\n");
    }

    // Include all of the custom code
    bldr.Append($"goto_sect {opt.SectionName}\n");
    foreach (var custom in eden)
    {
        bldr.Append($"%include \"{custom}\"\n");
    }

    // Append the remaining data
    bldr.Append("goto_addr end");
    
    // Write the script to the source directory
    File.WriteAllText("src/client.asm", bldr.ToString());
}

void BuildMacros(StringBuilder bldr, PeFile pe, Options opt)
{
    bldr.Append($"%define target \"{opt.Output}\"\n");
    bldr.Append($"imagebase equ {pe.ImageNtHeaders?.OptionalHeader.ImageBase.ToHexString()}\n");
    
    // define a headers pseudo section
    var firstSection = pe.ImageSectionHeaders.First();
    bldr.Append($"virt.hdrs equ {firstSection.ImageBaseAddress.ToHexString()}\n");
    bldr.Append("raw.hdrs equ 0\n");
    bldr.Append($"rsize.hdrs equ {firstSection.PointerToRawData.ToHexString()}\n");
    bldr.Append($"hdrs_vsize equ {pe.ImageNtHeaders.OptionalHeader.SizeOfHeaders.ToHexString()}\n");
    bldr.Append("hdrs_end equ virt.hdrs + hdrs_vsize\n");

    bldr.Append("section .hdrs vstart=virt.hdrs\n");
    foreach (var section in pe.ImageSectionHeaders)
    {
        var name = section.Name[1..];
        var absPosition = section.ImageBaseAddress + section.VirtualAddress;
        
        bldr.Append($"virt.{name} equ {absPosition.ToHexString()}\n");
        bldr.Append($"raw.{name} equ {section.PointerToRawData.ToHexString()}\n");
        bldr.Append($"rsize.{name} equ {section.SizeOfRawData.ToHexString()}\n");
        bldr.Append($"{name}_vsize equ {section.VirtualSize.ToHexString()}\n");
        bldr.Append($"{name}_end equ virt.{name} + {name}_vsize\n");
    }
    
    for (var i = 0; i < pe.ImageSectionHeaders.Length; i++)
    {
        var name = pe.ImageSectionHeaders[i].Name[1..];
        bldr.Append($"section .{name} vstart=virt.{name} ");
        if (i > 0)
        {
            var prevName = pe.ImageSectionHeaders[i - 1].Name[1..];
            bldr.Append($"follows=.{prevName}");
        }
        else
        {
            bldr.Append("follows=.hdrs");
        }

        bldr.Append('\n');
    }
    
    // start in the headers pseudo section
    bldr.Append("section .hdrs\n");
    bldr.Append("%assign cur_raw raw.hdrs\n");
    bldr.Append("%assign cur_virt virt.hdrs\n");
    bldr.Append("%assign cur_rsize rsize.hdrs\n");
    
    // Macro to move to the start of a new section
    bldr.Append(@"
%macro goto_sect 1
                incbin      target, cur_raw + ($-$$), raw%1 - (cur_raw + ($-$$))
                section     %1
    %assign cur_raw  raw%1
    %assign cur_virt virt%1
    %assign cur_rsize rsize%1
%endmacro
    ");
    
    // Macro to move forward within a section
    bldr.Append(@"
%macro goto_addr 1
    %ifidn %1, end
                incbin      target, cur_raw + ($-$$)
    %elif %1 >= cur_virt && %1 < cur_virt + cur_rsize
                incbin      target, cur_raw + ($-$$), %1 - (cur_virt + ($-$$))
    %else
        %error address %1 out of section range
    %endif
%endmacro
");
}

/// <summary>
/// The command-line arguments for the build script.
/// </summary>
class Options
{
    [Option("input", Required = true, HelpText = "The original game client from Gamigo")]
    public string Input { get; set; } = "game.exe";

    [Option("output", Required = true, HelpText = "The output game client")]
    public string Output { get; set; } = "game.exe";

    [Option("sectionsize", Default = "1MB", HelpText = "The size of the additional code section")]
    public string SectionSize { get; set; }
    
    [Option("sectionname", Default = ".eden", HelpText = "The name of the additional code section")]
    public string SectionName { get; set; }
    
    [Option("profile", Default = "debug", HelpText = "The build profile")]
    public string Profile { get; set; }
}

class Import
{
    public string Module { get; set; }
    public List<string> Functions { get; set; }
}